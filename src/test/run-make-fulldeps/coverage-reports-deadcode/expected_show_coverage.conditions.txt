    1|       |#![allow(unused_assignments, unused_variables)]
    2|       |
    3|      1|fn main() {
    4|      1|    let mut countdown = 0;
    5|      1|    if true {
    6|      1|        countdown = 10;
    7|      1|    }
    8|       |
    9|       |    const B: u32 = 100;
   10|      1|    let x = if countdown > 7 {
   11|      1|        countdown -= 4;
   12|      1|        B
   13|      0|    } else if countdown > 2 {
   14|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   15|      0|            countdown = 0;
   16|      0|        }
   17|      0|        countdown -= 5;
   18|      0|        countdown
   19|       |    } else {
   20|      0|        return;
   21|       |    };
   22|       |
   23|      1|    let mut countdown = 0;
   24|      1|    if true {
   25|      1|        countdown = 10;
   26|      1|    }
   27|       |
   28|      1|    if countdown > 7 {
   29|      1|        countdown -= 4;
   30|      1|    } else if countdown > 2 {
                            ^0
   31|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   32|      0|            countdown = 0;
   33|      0|        }
   34|      0|        countdown -= 5;
   35|       |    } else {
   36|      0|        return;
   37|       |    }
   38|       |
   39|      1|    if true {
   40|       |        // Demonstrate the difference with `TerminatorKind::Assert` as of 2020-11-15. Assert is no
   41|       |        // longer treated as a `BasicCoverageBlock` terminator, which changed the coverage region,
   42|       |        // for the executed `then` block above, to include the closing brace on line 30. That
   43|       |        // changed the line count, but the coverage code region (for the `else if` condition) is
   44|       |        // still valid.
   45|       |        //
   46|       |        // Note that `if` (then) and `else` blocks include the closing brace in their coverage
   47|       |        // code regions when the last line in the block ends in a semicolon, because the Rust
   48|       |        // compiler inserts a `StatementKind::Assign` to assign `const ()` to a `Place`, for the
   49|       |        // empty value for the executed block. When the last line does not end in a semicolon
   50|       |        // (that is, when the block actually results in a value), the additional `Assign` is not
   51|       |        // generated, and the brace is not included.
   52|       |        // TODO(richkadel): Add a FIXME(?????) with Issue and refer to the discussion at:
   53|       |        // https://github.com/rust-lang/rust/pull/79109#discussion_r525612860
   54|      1|        let mut countdown = 0;
   55|      1|        if true {
   56|      1|            countdown = 10;
   57|      1|        }
   58|       |
   59|      1|        if countdown > 7 {
   60|      1|            countdown -= 4;
   61|      1|        }
   62|       |        // The closing brace of the `then` branch is now included in the coverage region, and shown
   63|       |        // as "executed" (giving its line a count of 1 here). Since, in the original version above,
   64|       |        // the closing brace shares the same line as the `else if` conditional expression (which is
   65|       |        // not executed if the first `then` condition is true), only the condition's code region is
   66|       |        // marked with a count of 0 now.
   67|      0|        else if countdown > 2 {
   68|      0|            if countdown < 1 || countdown > 5 || countdown != 9 {
   69|      0|                countdown = 0;
   70|      0|            }
   71|      0|            countdown -= 5;
   72|       |        } else {
   73|      0|            return;
   74|       |        }
   75|      1|    }
   76|       |
   77|      1|    let mut countdown = 0;
   78|      1|    if true {
   79|      1|        countdown = 1;
   80|      1|    }
   81|       |
   82|      1|    let z = if countdown > 7 {
                      ^0
   83|      0|        countdown -= 4;
   84|      1|    } else if countdown > 2 {
   85|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   86|      0|            countdown = 0;
   87|      0|        }
   88|      0|        countdown -= 5;
   89|       |    } else {
   90|      1|        let should_be_reachable = countdown;
   91|      1|        println!("reached");
   92|      1|        return;
   93|       |    };
   94|       |
   95|      0|    let w = if countdown > 7 {
   96|      0|        countdown -= 4;
   97|      0|    } else if countdown > 2 {
   98|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   99|      0|            countdown = 0;
  100|      0|        }
  101|      0|        countdown -= 5;
  102|       |    } else {
  103|      0|        return;
  104|       |    };
  105|      1|}

